package hook

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

const (
	markerStart = "# repowiki hook start"
	markerEnd   = "# repowiki hook end"
)

func hookPath(gitRoot string) string {
	return filepath.Join(gitRoot, ".git", "hooks", "post-commit")
}

// Script generates the hook script using the absolute path to the repowiki binary.
func Script(binaryPath string) string {
	return markerStart + `
# Auto-generated by repowiki â€” do not edit this block
REPOWIKI_BIN="` + binaryPath + `"
if [ -x "$REPOWIKI_BIN" ]; then
  "$REPOWIKI_BIN" hooks post-commit &
elif command -v repowiki >/dev/null 2>&1; then
  repowiki hooks post-commit &
fi
` + markerEnd
}

func Install(gitRoot string, force bool, binaryPath string) error {
	hp := hookPath(gitRoot)

	// Ensure hooks directory exists
	if err := os.MkdirAll(filepath.Dir(hp), 0755); err != nil {
		return fmt.Errorf("failed to create hooks dir: %w", err)
	}

	// Read existing hook file if present
	data, err := os.ReadFile(hp)
	if err == nil {
		content := string(data)
		if strings.Contains(content, markerStart) {
			if !force {
				return fmt.Errorf("repowiki hook already installed; use --force to reinstall")
			}
			content = removeBlock(content)
		}
		content = strings.TrimRight(content, "\n") + "\n\n" + Script(binaryPath) + "\n"
		return os.WriteFile(hp, []byte(content), 0755)
	}

	// Create new hook file
	content := "#!/bin/sh\n\n" + Script(binaryPath) + "\n"
	return os.WriteFile(hp, []byte(content), 0755)
}

func Uninstall(gitRoot string) error {
	hp := hookPath(gitRoot)
	data, err := os.ReadFile(hp)
	if err != nil {
		return nil // No hook file
	}

	content := removeBlock(string(data))
	trimmed := strings.TrimSpace(content)

	// If only shebang remains, remove the file
	if trimmed == "#!/bin/sh" || trimmed == "" {
		return os.Remove(hp)
	}

	return os.WriteFile(hp, []byte(content), 0755)
}

func IsInstalled(gitRoot string) bool {
	data, err := os.ReadFile(hookPath(gitRoot))
	if err != nil {
		return false
	}
	return strings.Contains(string(data), markerStart)
}

func removeBlock(content string) string {
	startIdx := strings.Index(content, markerStart)
	endIdx := strings.Index(content, markerEnd)
	if startIdx == -1 || endIdx == -1 {
		return content
	}
	endIdx += len(markerEnd)
	// Also remove trailing newline after the block
	if endIdx < len(content) && content[endIdx] == '\n' {
		endIdx++
	}
	return content[:startIdx] + content[endIdx:]
}
